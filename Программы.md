# Готовые программы:
<br>

## Hello arrow world
Выводит на экран надпись "Hello arrow world".
```asm
ldi b, 0x0c; адрес фрагмента изображения
ldi c, 0x20; количество циклов программы
loop:
ld a, b    ; чтение фрагмента в ОЗУ по адресу B
out a, d   ; вывод значений на экран
inc b      ; смещение адреса B на следующую ячейку памяти
inc d      ; смещение адреса монитора на следующий фрагмент
dec c      ; уменьшение значения счётчика
jnz loop   ; проверка флага Z, переход на начало цикла
hlt        ; окончание программы по завершению цикла
image db 0b10100000, 0b00000000,
         0b10100100, 0b10100100,
         0b11101010, 0b10101010,
         0b10101100, 0b10101010,
         0b10100110, 0b10100100,
         0b00000000, 0b00000000,
         0b01000000, 0b00000000,
         0b10100101, 0b00100101,
         0b10101010, 0b01010111,
         0b11101010, 0b01010111,
         0b10101010, 0b00100010,
         0b00000000, 0b00000000,
         0b10100100, 0b01010001,
         0b11101010, 0b10010011,
         0b11101010, 0b10010101,
         0b01000100, 0b10010011;
```
<br>

## I/O driver
Нужен для правильной работы устройств ввода-вывода.
```asm
loop:
in d       ; прочитать младшую часть шестнадцатибитного значения
in c       ; прочитать старшую часть шестнадцатибитного значения
out d, c   ; вывести шестнадцатибитое значения
jmp loop   ; переход на начало цикла
```
<br>

## Fibonacci sequence
Вычисляет первые 25 чисел Фибоначчи.
```asm
inc c      ; второе число - 1
loop:
add a, c   ; складываем числа
adc b, d   ; складываем числа
jc 0x16    ; проверка шестнадцатибитности числа
st c, 0x11 ; записать младшую часть числа
st d, 0x13 ; записать старшую часть числа
ldi d, 0x10; прочитать координаты для экрана
out a, d   ; вывести младшую часть
clr d      ; прочитать координаты для экрана
out b, d   ; вывести старшую часть
mov c, a   ; перенести данные
mov d, b   ; перенести данные
ldi a, 0x00; прочитать младшую часть числа
ldi b, 0x00; прочитать старшую часть числа
jmp loop   ; переход в начало
hlt        ; завершение программы
```
<br>

## Binary search
Находит порядковый номер символа в массиве из 224 чисел. Поддерживает все символьные кнопки клавиатуры с любыми клавишами-модификаторами.
```asm
in d       ; ввести символ
in c       ; обязательный ввод
st d, num1 ; записать символ
ldi c, 0x70; длина массива делённая на два
mov a, c   ; адрес символа
ldi d, 0x1e; длина смещения
shr c      ; поделить на два длину массива
adc c, d   ; прибавить один, если число было нечётное
sub c, d   ; убавить лишнее
add a, d   ; прибавить смещение
ld b, a    ; прочитать символ
sub a, d   ; убавить смещение
ld d, num1 ; прочитать символ
sub b, d   ; сравнить числа
jc 0x19    ; переход, если число меньше
jz 0x1c    ; переход, если число нужное
sub a, c   ; смещение в меньшую сторону
jmp 0x07   ; переход в начало цикла
add a, c   ; смещение в большую сторону
jmp 0x07   ; переход в начало цика
out a, b   ; вывести номер числа
jmp b      ; переход в начало программы
num1 db 0b00000000; вводимое число
num2 db 0b00100000,
         \\\"Числа от 100000 до 11111111"
0b11111111; массив чисел
```
<br>

## Calculator
Калькулятор, поддерживающий целые числа от 0 до 255. Имеет операции +, -, *, /, s (корень), ^. Для каждой операции нужно нажать соответственную кнопку. Раскладку нужно использовать стандартную английскую. После ввода каждого числа нужно нажимать enter для подтверждения завершения ввода числа. На сегментном экране будут отображаться все значения. После получения ответа нажмите любую кнопку, чтобы очистить экран и приготовить программу к следующей операции.
```asm
enter equ 0b00001000;
equals equ 0b11000100;
signDataM1 equ signData - 1;
signDataSize equ adressData - signData;
enterTrueP1 equ enterTrue + 1;
endOfOperationAdressP1 equ endOfOperationAdress + 1;
requiredData equ 0b00100000;
responseOutputDataP2 equ responseOutputData + 2;


in a; чтение символа из клавиатуры
in d; обязательное чтение
ldi b, enter; прочитать код enter
xor b, a; сравнить данные
enterTrue: jz endOfNum; переход к следующему числу
out a, d; вывод символа на экран
ldi b, digitData; метка начала данных символов
mov d, b; запомнить метку
loop0: ld c, b; прочитать данные символа
xor c, a; сравнить данные
jz endOfDigitSelection; переход к вычислению числа
inc b; сдвинуть метку начала цифр
jmp loop0; перейти к началу цикла
endOfDigitSelection: sub b, d; получить число
ld a, num2; прочитать нынешнее число
rcl a; умножить число на 2
mov d, a; запомнить полученное
rcl a; умножить число на 4
rcl a; умножить число на 8
add a, d; получить число умноженное на 10
add a, b; получить нужное число
st a, num2; записать нынешнее число
jmp c; перейти в начало
endOfNum: in a; чтение символа из клавиатуры
in b; обязательное чтение
out a, b; вывод символа на экран
ld b, num2; прочитать первое число
st b, num1; записать первое число
ldi b, signDataM1; метка начала данных знаков
loop1: inc b; сдвинуть метку начала знаков
ld c, b; прочитать данные
xor c, a; сравнить данные
jnz loop1; перейти в начало цикла
st c, num2; подготовиться к второму числу
ldi d, signDataSize; размер блока данных знаков
add b, d; получить адрес знака
ld a, b; прочитать адрес вычисления
ldi b, operationAdress; адрес перехода к вычислениям
st b, enterTrueP1; записать адрес перехода к вычислениям
st a, endOfOperationAdressP1; записать адрес вычисления
jmp c; перейти в начало
operationAdress: ldi b, equals; прочитать код =
out b, d; вывести =
out a, d; вывести enter
ld a, num1; прочитать первое число
ld b, num2; прочитать второе число
endOfOperationAdress: jmp 0b0; перейти к операции


addition: add a, b; сложить значения
jmp responseOutput; перейти к блоку перевода системы счисления

subtraction: sub a, b; вычесть значения
jmp responseOutput; перейти к блоку перевода системы счисления

multiplication: mov c, a; перенести значение 
clr a; подготовка для произведения
ldi d, 0b00001000; длина цикла
loop5: shr b; проверка младшего разряда
jnc loop4; переход к продолжению цикла
add a, c; увеличение произведения
loop4: shl c; увеличение первого множителя
dec d; уменьшение длины цикла
jnz loop5; переход к началу цикла
jmp responseOutput; перейти к блоку перевода системы счисления

divider: mov c, a; перенести значение
clr a; подготовка для частного
add b, a; прибавляем ноль
jz responseOutput; если делитель ноль, перейти к блоку перевода системы счисления
ldi d, 0b00000001; начальная метка разряда частного
loop6: shl b; увеличиваем делитель
jc loop7; перейти к продолжению вычисления
shl d; сдвинуть метку разряда частного
jmp loop6; перейти к началу цикла
loop7: rcr b; исправляем переполнение
loop8: sub c, b; вычитаем делитель из делимого
jnc loop9; переход к увеличению частного
add c, b; исправляем переполнение
sub a, d; вычитаем лишний разряд
loop9: add a, d; складываем метку разряда и частное
shr b; уменьшаем делитель
shr d; уменьшаем метку разряда
jnc loop8; переход в начало цикла
jmp responseOutput; перейти к блоку перевода системы счисления

sqrt: mov b, a; перенести значение
clr a; подготовка для корня
ldi d, 0b00000010; число для прибавления
ldi c, 0b00000001; число для вычитания
loop9: sub b, c; вычитаем нечётное число
jc responseOutput; перейти к блоку перевода системы счисления
inc a; увеличить корень
add c, d; увеличить число для вычитания
jmp loop9; перейти в начало цикла

power: ldi a, 0b00000001; подготовка еденицы
mov c, b; подготовка регистра
or c, b; проверка степени на ноль
jz responseOutput; перейти к блоку перевода системы счисления
ld a, num1; чтение числа
loop10: ld c, num2; чтение степени
dec c; уменьшение степени
jz responseOutput; перейти к блоку перевода системы счисления
st c, num2; запись степени
ld b, num1; чтение множителя
mov c, a; перенести значение 
clr a; подготовка для произведения
ldi d, 0b00001000; длина цикла
loop12: shr b; проверка младшего разряда
jnc loop11; переход к продолжению цикла
add a, c; увеличение произведения
loop11: shl c; увеличение первого множителя
dec d; уменьшение длины цикла
jnz loop12; переход к началу цикла
jmp loop10; перейти к началу цикла


responseOutput: ldi d, responseOutputData; чтение адреса значений для перевода системы счисления
loop3: ldi b, num2; запись адреса перед digitData
ld c, d; чтение значений для перевода системы счисления
loop2: inc b; увеличение адреса
sub a, c; вычисление третьего разряда
jnc loop2; переход в начало цикла
add a, c; возвращение положительного числа
ld c, b; чтение кода цифры
ldi b, requiredData; чтение обязательных для вывода данных
out c, b; вывод цифры
ldi b, responseOutputDataP2; чтение конечного адреса
xor b, d; проверка адреса
jz end; переход к подготовке следующего цикла программы
inc d; увеличение адреса значений для перевода систем счисления
jmp loop3; переход к началу цикла
end: clr a; очистить регистр
st a, num2; очистить ячейку
ldi a, endOfNum; прочитать нужный адрес
st a, enterTrueP1; записать адрес в нужную ячейку
in a; ожидание нажатия любой кнопки
in a; обязательное чтение
ldi b, 0b00011001; чтение команды очистки ячеек
out b, a; вывод команды
ldi b, 0b00011010; чтение команды перемещения курсора вверх
out b, a; вывод команды
ldi b, 0b00011001; чтение команды очистки ячеек
out b, a; вывод команды
jmp 0b0; переход к началу приложения


num1 db 0x00; первое число
num2 db 0x00; второе число
digitData db 0b10111100,          ; 0
0b00100000,                       ; 1
0b01000000,                       ; 2
0b01000100,                       ; 3
0b11001100,                       ; 4
0b01100000,                       ; 5
0b11001000,                       ; 6
0b11010000,                       ; 7
0b10000000,                       ; 8
0b10111000                        ; 9
responseOutputData db 0b01100100, ; 100
0b00001010,                       ; 10
0b00000001                        ; 1
signData db 0b11000101,           ; +
0b11000000,                       ; -
0b10000001,                       ; *
0b10110100,                       ; /
0b01100100,                       ; s
0b11001001                        ; ^
adressData db addition,           ; адрес +
subtraction,                      ; адрес -
multiplication,                   ; адрес *
divider,                          ; адрес /
sqrt,                             ; адрес s
power                             ; адрес ^
```
<br>

## Rock, paper, scissors
Детская игра "камень, ножницы, бумага". На пульте выберите нужную фигуру, после в зависимости от победителя кому-то дадут щелбан. На экране будут отображаться персонажи и фигуры, а на сегментном экране результат игры.
```asm
textDataM1 equ textData - 1;

ldi d, 0b00100011; код картинок
start: clr b; подготовка регистра
out b, d; вывести картинку
ldi a, 0b00100010; код текстов
out b, a; вывести текст
loop0: rnd a; создание случайного значения
shr a; проверка бита
rcl b; перемещение бита
shr a; проверка бита
rcl b; перемещение бита
jz loop0; переход в начало цикла
in a; чтение кода фигуры
in c; обязательное чтение
out b, d; вывести нужную фигуру
ldi c, 0b00000011; размер сдвига
add c, a; сдвиг метки изображений
out c, d; вывести нужную фигуру
add a, b; сравнить фигуры
ldi b, 0b00000100; создание маски
and b, a; выбор нужного бита
jz loop1; проверка нужного бита
sub a, b; удаление лишнего бита
inc a; увеличение значения
loop1: ldi b, textDataM1; чтение нужного адреса
add a, b; получение нужного адреса
ld b, a; чтение нужного кода изображения
ldi c, 0b00100010; код текстов
out b, c; вывести нужный текст
ldi c, 0b00000110; чтение сдвига
add b, c; сдвиг метки изображений
out b, d; вывести нужное изображение
st b, delay; замедление
st b, delay; замедление
st b, delay; замедление
jmp start; перейти в начало
textData db 0b00000001, ; ничья
            0b00000010, ; выигрыш
            0b00000011  ; поражение
delay db 0x00           ; свободная ячейка
```
